1
00:00:05,740 --> 00:00:06,910
皆を歓迎します。

2
00:00:06,910 --> 00:00:13,310
ここでは、さまざまなオブジェクトタイプを保持できるシーケンスをPythonリストまたは順序順で説明し、リスト内のオブジェクトを区切るために角かっこやカンマを使用してみましょう。

3
00:00:13,310 --> 00:00:18,110
&nbsp;

4
00:00:18,110 --> 00:00:24,350
例えばここでは数字のリストを見ることができ、文字列が索引付けとスライシングをサポートしているのと同じようにリストされます。また、ネストすることもできますし、呼び出すことができるさまざまな便利なメソッドがあります。

5
00:00:24,350 --> 00:00:29,270
&nbsp;

6
00:00:29,270 --> 00:00:30,160
&nbsp;

7
00:00:30,170 --> 00:00:32,740
木星ノートブックでこれらの概念をすべて探そう。

8
00:00:32,990 --> 00:00:41,330
私のリストと呼ばれる変数を定義することから始めて、それを1から3の番号に設定します。

9
00:00:41,340 --> 00:00:44,480
ここでは、リストが角括弧で定義されていることがわかります。

10
00:00:44,520 --> 00:00:48,390
そして、すべてのオブジェクトタイプをコンマで区切ります。

11
00:00:48,390 --> 00:00:53,040
整数のリストを作成するだけですが、混合オブジェクト型のリストを作成することもできます。

12
00:00:53,040 --> 00:00:56,040
最初の文字列は文字列だった可能性があります。

13
00:00:56,040 --> 00:01:02,730
&nbsp;

14
00:01:02,730 --> 00:01:07,890
&nbsp;

15
00:01:08,190 --> 00:01:13,320
&nbsp;

16
00:01:13,320 --> 00:01:19,530
2番目のものは数値か浮動小数点だった可能性があり、リストに問題はないので、Pythonのリストは保持できるデータ型に非常に柔軟性があり、リストの長さを確認したい場合は、文字列の長さ私たちはPythonに組み込まれたLCN関数を使用してから私のリストを渡し、そのリストにいくつの要素または項目があるかを返します。

17
00:01:19,530 --> 00:01:24,440
だからここには3つのアイテムストリング123のポイント2があります。

18
00:01:24,450 --> 00:01:29,390
リストは順序付けられた要素のシーケンスなので、文字列のようになります。

19
00:01:29,520 --> 00:01:33,310
インデックス作成とスライスを使うことができます。これは文字列のように機能します。

20
00:01:33,300 --> 00:01:34,980
それで、私がそれを意味するものを見せてあげましょう。

21
00:01:35,130 --> 00:01:46,390
私は私のリストが1から3を実行すると言うことと同じであると言うでしょう。

22
00:01:46,740 --> 00:01:50,070
そして、もし私が0を指すように要素をつかみたいならば。

23
00:01:50,070 --> 00:01:57,130
だから、それは私のリスト0を実行し、私は1に戻り、インデックス1から始まるすべてを最後まで取得したいのであれば、最初の要素です。

24
00:01:57,140 --> 00:02:00,970
&nbsp;

25
00:02:01,030 --> 00:02:03,720
まあ、それは文字列インデックスと文字列スライシングのようなものです。

26
00:02:03,870 --> 00:02:09,890
私はちょっと、コロンを一つにまとめてインデックスを作成し始めたら、2つと3つのコロンがあると言うでしょう。

27
00:02:09,900 --> 00:02:17,620
したがって、このスライシングとインデックス作成は文字列のように機能し、これらをすべて連結することもできます。

28
00:02:17,640 --> 00:02:19,480
ここでこれを見てみましょう。

29
00:02:19,620 --> 00:02:22,770
今私のリストは1つ2つ3つあります。

30
00:02:23,040 --> 00:02:35,640
私は4 5と言うことに等しい他のリストを作成して、私のリストを他のリストに見ることができ、新しいリストに連結します。

31
00:02:35,640 --> 00:02:39,080
&nbsp;

32
00:02:39,090 --> 00:02:41,330
1 2 3 4 5。

33
00:02:41,340 --> 00:02:43,850
ここで私は実際にこの結果を保存しています。

34
00:02:43,950 --> 00:02:50,170
だから私がリストや他のリストを呼び戻すなら、私はここでタブオートコンプリートを使うことができます。

35
00:02:50,280 --> 00:02:54,300
&nbsp;

36
00:02:54,810 --> 00:03:02,820
私は実際にこれを保存したい場合、私はまだそれらの2つの別々のリストを持っています私は何かにそれを割り当てる必要があるので、新しいリストが私のリストと他のリストと等しいと言うことができるので、五。

37
00:03:02,870 --> 00:03:04,710
&nbsp;

38
00:03:05,140 --> 00:03:05,720
OK。

39
00:03:05,850 --> 00:03:08,100
だから、それはリスナーの基本です。

40
00:03:08,130 --> 00:03:17,620
ここではインデックスのスライスを行い、連結は文字列とはかなり似ているはずですが、ここでは文字列とは違う点を除いて、実際にリストの周りで変更や変更ができることです。

41
00:03:17,620 --> 00:03:22,720
&nbsp;

42
00:03:22,720 --> 00:03:28,480
文字列の周りの手紙を変更しようとしているときに、それが私たちのリストに問題を起こさせないようにすることを忘れないでください。

43
00:03:28,540 --> 00:03:30,140
&nbsp;

44
00:03:30,160 --> 00:03:34,970
だから私が新しいリストをチェックアウトすると、それは1 2 3 4 5です。

45
00:03:35,120 --> 00:03:40,510
これらの要素のうちの1つを変更して、すべてを変更するようにしましょう。

46
00:03:40,550 --> 00:03:47,130
私ができることは、ポジション0の新しいリストがすべての大文字で1に等しいと言うことです。

47
00:03:47,130 --> 00:03:49,160
今、私たちがそれを変えていることを本当に明白にしましょう。

48
00:03:49,210 --> 00:03:58,440
だから私はすべての帽子を言うとき、今私は私の新しいリストを見てみると、私はすべてのキャップが2つ3つの4つ5つを持っています。

49
00:03:58,450 --> 00:03:59,270
&nbsp;

50
00:03:59,360 --> 00:04:04,320
つまり、すでにリストにある要素を実際に変更または変更することができます。

51
00:04:04,380 --> 00:04:07,180
それは文字列と区別するものです。

52
00:04:07,180 --> 00:04:12,100
それはまた、さまざまな要素の種類と中括弧とコンマを保持しているという事実の他にもあります。

53
00:04:12,110 --> 00:04:16,090
文字列を変更して内部の要素に影響を与えることができます。

54
00:04:17,290 --> 00:04:22,850
実行する他の一般的な操作では、リストの最後に要素を追加します。

55
00:04:23,290 --> 00:04:29,830
そして、私たちができることは、最新のドットとヒットタブをここで言うことです。あなたはリスト内で利用可能なさまざまな方法をすべて見るべきです。

56
00:04:29,830 --> 00:04:32,530
&nbsp;

57
00:04:32,530 --> 00:04:39,400
ここでは、appendメソッドを示し、appendを使用すると、リストの最後に新しいアイテムを追加できます。

58
00:04:39,400 --> 00:04:40,720
&nbsp;

59
00:04:41,050 --> 00:04:48,950
だから私は6を追記して、これをよく読んだ後、私が新しいリストをチェックすると、私は1つのキャップがすべて2 3 4

60
00:04:50,420 --> 00:04:54,860
5であり、今では6つあることがわかります。

61
00:04:54,860 --> 00:05:01,400
ペンが実際にリストにどのような影響を与えているかに注目してください。これは、新しいリストがこのリストの最後に要素を持つように永久に変更するため、場所に影響を与えます。

62
00:05:01,400 --> 00:05:06,280
&nbsp;

63
00:05:06,290 --> 00:05:07,560
これはペンと呼ばれています。

64
00:05:07,580 --> 00:05:10,760
また、リストの最後に項目を配置することもできます。

65
00:05:10,760 --> 00:05:12,630
もう一度試してみましょう。

66
00:05:12,720 --> 00:05:20,910
私はあなたのペンをリストして送るでしょう。私は7チェッカーを実行し、あなたがリストし、私はすべての大文字を見ることができます。

67
00:05:20,910 --> 00:05:22,520
2 3 4 5 6。

68
00:05:22,560 --> 00:05:25,830
そして、私はここで非常にズームインしているだけなので、それを切り捨てるのが一種です。

69
00:05:26,010 --> 00:05:30,180
しかし、あなたがズームアウトしていたら、もっと普通のやり方で見ることになります。

70
00:05:30,180 --> 00:05:30,500
大丈夫。

71
00:05:30,540 --> 00:05:32,550
だから私たちはリストに物を追加する方法を知っている。

72
00:05:32,550 --> 00:05:34,790
リストから項目を削除する方法について話しましょう。

73
00:05:34,890 --> 00:05:37,590
これを行うには、popメソッドを使用できます。

74
00:05:37,680 --> 00:05:43,960
だからポップは実際にはリストの最後から項目をポップアウトします。

75
00:05:44,000 --> 00:05:45,480
それが何を意味するのかを見てみましょう。

76
00:05:45,680 --> 00:05:52,200
これらのメソッド呼び出しの多くで、ポップの開いた印字と閉じた印字が混乱しているという新しいリストが出てきます。

77
00:05:52,220 --> 00:05:54,580
あなたがプリンスを持っていない場合は、そこにあり、あなたはそれらを実行します。

78
00:05:54,710 --> 00:05:55,650
それは報告するつもりです。

79
00:05:55,660 --> 00:05:59,070
ちょっと、この最新のオブジェクトの中のポップ機能です。

80
00:05:59,090 --> 00:06:02,930
実際にそれを呼びたい場合は、かっこを閉じて閉じておく必要があります。

81
00:06:02,930 --> 00:06:06,230
そして、後で、メソッドと関数の違いについて議論します。

82
00:06:06,260 --> 00:06:09,770
あなたはおそらく私がこれらの用語を少しでも交換可能に使用すると聞いてきましたが、今度はそれらについて後ほど詳しく説明します。

83
00:06:09,770 --> 00:06:11,330
&nbsp;

84
00:06:11,630 --> 00:06:17,960
しかし、今、私たちはリストを言ったことがわかりました。それはポップであり、7から飛び出しました。実際には戻ってきました。

85
00:06:17,960 --> 00:06:18,810
&nbsp;

86
00:06:20,210 --> 00:06:25,380
そして、新しいリストが何であるかを見れば、もはやそれには文字列7がありません。

87
00:06:25,380 --> 00:06:28,350
これで文字列6に移動します。

88
00:06:28,350 --> 00:06:31,380
実際にはポップの結果が保存されます。

89
00:06:31,440 --> 00:06:42,700
だから、ポップされたアイテムは新しいリストと等しいと私はドロップポップと言うつもりだと言うことができます。

90
00:06:42,830 --> 00:06:47,900
そして、これを実行すると、このポップアイテムは、そのリストの最後にあったアイテムになります。

91
00:06:47,900 --> 00:06:48,610
&nbsp;

92
00:06:48,740 --> 00:06:56,330
だから、私はこのポップアイテムをコピーして貼り付けることができます。そして今、私はポップアイテムが6つあり、それはもはや私のリストの一部ではないと言います。

93
00:06:56,330 --> 00:06:58,110
&nbsp;

94
00:06:58,160 --> 00:07:03,820
ここでよく起こる質問は、リストの最後から何かを削除したくないということです。

95
00:07:04,010 --> 00:07:10,870
特定のインデックスで削除する場合は、インデックス0のすべてのインデックスを削除したいとします。

96
00:07:11,090 --> 00:07:12,310
まあ、実際には問題ありません。

97
00:07:12,320 --> 00:07:18,870
あなたは、私たちが言うことができるポップにインデックスの位置を渡すことができ、あなたはポップをリストし、次に削除したいもののインデックス位置に渡します。

98
00:07:18,870 --> 00:07:21,260
&nbsp;

99
00:07:21,270 --> 00:07:25,110
ここでは、すべての大文字がインデックス位置0であることがわかります。

100
00:07:25,200 --> 00:07:27,300
だからそこのパサンド0だ。

101
00:07:27,420 --> 00:07:27,920
それを実行します。

102
00:07:27,930 --> 00:07:35,750
今、私たちはすべての大帽子を奪ったことがわかります。あなたが今リストすると、私たちは2 3 4 5を持っています。

103
00:07:36,040 --> 00:07:41,230
だから、popは基本的に、あなたが提供した場所のリストから項目を削除します。

104
00:07:41,290 --> 00:07:44,260
デフォルトでは、インデックスの位置は負です1。

105
00:07:44,290 --> 00:07:45,830
リストの最後。

106
00:07:45,910 --> 00:07:53,240
&nbsp;

107
00:07:53,240 --> 00:07:59,720
&nbsp;

108
00:07:59,720 --> 00:08:00,860
だから、逆インデックスもリストのように動作します。これは、文字列のために働いたのと同じように、popとappend以外に議論したいメソッドがあります。

109
00:08:00,860 --> 00:08:03,040
だから私はこれを行うために新しいリストを作成します。

110
00:08:03,050 --> 00:08:04,220
ズームインしましょう。

111
00:08:05,170 --> 00:08:11,170
だから私は細かいリストを読んで、最終的なリストをここにいくつかの手紙にするつもりですが、私たちはアルファベット順からソートしていきます。

112
00:08:11,170 --> 00:08:13,930
&nbsp;

113
00:08:17,270 --> 00:08:18,220
&nbsp;

114
00:08:18,340 --> 00:08:22,540
また、数値リストを作成して、nimblestが等しいと言います。

115
00:08:22,540 --> 00:08:25,650
そして、これを数だけ並べ替えてみましょう。

116
00:08:27,270 --> 00:08:28,900
2つのリストがあります。

117
00:08:28,950 --> 00:08:35,280
これらのリストを並べ替えるには、並べ替え方法と呼ばれるものを並べ替える必要がある場合は、新しいリスト並べ替えが表示され、タブの自動補完機能を使用してこれを行うことができます。

118
00:08:35,280 --> 00:08:39,680
&nbsp;

119
00:08:39,970 --> 00:08:46,060
閉じたカッコを開きます。実際には何も返さないため、これは実際には場所指定のメソッドのようなものです。

120
00:08:46,060 --> 00:08:47,050
&nbsp;

121
00:08:47,110 --> 00:08:49,510
代わりに、それは並べ替えるつもりです。

122
00:08:49,510 --> 00:08:53,260
その場所に新しいリストがあるので、何も返されません。

123
00:08:53,260 --> 00:08:58,090
代わりに新しいリストをもう一度呼び出すと、アルファベット順にソートされます。

124
00:08:58,090 --> 00:09:03,640
ABC Xとそれは重要な区別です。何度も初心者がこのようなことをするためです。

125
00:09:03,640 --> 00:09:04,620
&nbsp;

126
00:09:04,750 --> 00:09:12,380
彼らはああ私のソートされたリストは、あなたがその並べ替えをリストに等しいと言うでしょう。

127
00:09:12,750 --> 00:09:18,450
しかし、ここで何が起きるかは、その並べ替えが新しいリストが実際にあなたのために何も返さない場所に発生するためです。

128
00:09:18,450 --> 00:09:20,320
&nbsp;

129
00:09:20,340 --> 00:09:25,210
だからあなたが私の並べ替えられたリストを呼び出すと、あなたは何も戻ってこない。

130
00:09:25,270 --> 00:09:33,360
そして、実際にこのタイプをチェックすることができます。そして、それは血液型であり、どのタイプがnoneオブジェクトのタイプであると言うでしょう。

131
00:09:33,360 --> 00:09:36,050
&nbsp;

132
00:09:36,060 --> 00:09:41,640
&nbsp;

133
00:09:41,640 --> 00:09:47,460
だから、Pythonには実際にはnoneという名前の特別なオブジェクトがあります。そこには気がついていませんでした。そして、これは価値がないことを示すために使うことができ、多くの人がプレースホルダとして保持します。

134
00:09:47,610 --> 00:09:53,320
しかし実際には、それは実際に何も返さない関数またはメソッドの戻り値です。

135
00:09:53,550 --> 00:09:58,140
だから、何かを検索するかもしれず、それを見つけるかもしれないし、見つけられないかもしれない関数のための共通のデフォルト戻り値です。

136
00:09:58,140 --> 00:10:00,180
&nbsp;

137
00:10:00,180 --> 00:10:05,280
したがって、このソート方法を使用しているときは、実際にはその場所で発生していることに注意することが重要な違いです。

138
00:10:05,280 --> 00:10:06,480
&nbsp;

139
00:10:06,510 --> 00:10:10,420
だから、代わりに結果を他のものに代入することはできないでしょう。

140
00:10:10,440 --> 00:10:19,940
&nbsp;

141
00:10:19,940 --> 00:10:28,380
&nbsp;

142
00:10:28,830 --> 00:10:33,870
あなたがしなければならないことをしたいと思うならば、私のソートされたリストは新しいリストと等しいと言うあなたがそれを実行すると、あなたがそこにタブのオートコンプリートを使用して私のソートされたリストを持つことができます並べ替えられたリストを取得し、その番号リストをもう一度試してみてください。

143
00:10:33,870 --> 00:10:37,150
だから今リストはソートされていません。

144
00:10:37,200 --> 00:10:44,950
ソート方法を呼び出すと、今度はそれを並べ替えてチェックします。

145
00:10:45,000 --> 00:10:45,460
大丈夫。

146
00:10:45,690 --> 00:10:49,290
あなたが期待しているかもしれないように、リストから逆の方法について議論しましょう。

147
00:10:49,320 --> 00:10:51,960
それはあなたのリストのすべてを逆転させます。

148
00:10:51,960 --> 00:10:59,680
だから、逆開きの近くのプリントがそれを実行するのを見るだけで、何も返されないという意味にもなります。

149
00:10:59,800 --> 00:11:04,880
あなたのリストの逆のバージョンを呼ぶと、彼らは8 4 3 2を持っていました1。

150
00:11:04,890 --> 00:11:05,460
大丈夫。

151
00:11:05,520 --> 00:11:11,940
これは本当にリストの基本であり、理解するための最もサポートされているメソッドは、appendメソッドとpopメソッドだけでなく、並べ替えと逆のメソッドです。

152
00:11:11,940 --> 00:11:14,850
&nbsp;

153
00:11:14,940 --> 00:11:19,380
そして、文字列のようにインデックス作成とスライスを実行することができました。

154
00:11:19,380 --> 00:11:26,760
そこでここに戻ってきたら、ピアリングのような表記法だけでなく索引付けもできるようになります。

155
00:11:26,880 --> 00:11:30,750
あなたと同じように動作するので、文字列の場合と同じように機能します。

156
00:11:30,750 --> 00:11:35,450
ここで注意すべき唯一のことは、リストと同じように再割り当てを行うことができるストリングとは異なることです。

157
00:11:35,450 --> 00:11:36,590
&nbsp;

158
00:11:36,630 --> 00:11:37,010
OK。

159
00:11:37,080 --> 00:11:38,520
それがリストの基本です。

160
00:11:38,580 --> 00:11:41,100
次に、私たちは辞書について議論するつもりです。

161
00:11:41,100 --> 00:11:42,090
私はそこにそれを見るでしょう。
