1
00:00:05,370 --> 00:00:07,230
この講義で皆さんを歓迎します。

2
00:00:07,260 --> 00:00:11,610
文字列のプロパティと文字列メソッドについて説明して、文字列に関する議論を終わらせます。

3
00:00:11,610 --> 00:00:12,560
&nbsp;

4
00:00:12,570 --> 00:00:14,690
ノートブックにジャンプして始めましょう。

5
00:00:14,730 --> 00:00:19,210
私たちが議論する最初のことは、文字列の不変性と不変性です。

6
00:00:19,230 --> 00:00:25,240
Muttiという言葉に由来するのは、基本的には模倣するということです。そうでなければ、変異したり変更することはできません。

7
00:00:25,280 --> 00:00:26,930
私はこれの例をあなたに示します。

8
00:00:27,120 --> 00:00:32,330
nameという名前の変数を作成し、それをSamと同じに設定しましょう。

9
00:00:32,330 --> 00:00:35,700
今、この名前をPamに変更したいとしましょう。

10
00:00:35,720 --> 00:00:37,910
だからpをaに変更してください。

11
00:00:38,240 --> 00:00:41,050
あなたはこのようなことをすると思います。

12
00:00:41,240 --> 00:00:45,830
名前のインデックスを0とし、それをPに設定します。 今すぐ文字列のために。

13
00:00:45,860 --> 00:00:46,590
残念ながら、このコードを実行しようとすると、これを行うことはできません。

14
00:00:46,580 --> 00:00:49,330
&nbsp;

15
00:00:49,520 --> 00:00:55,580
文字列が文字列オブジェクトを意味する不変であるか、または階層オブジェクトがアイテム割り当てをサポートしないため、これらの文字のいずれかを取得できないため、エラーが発生します。

16
00:00:55,580 --> 00:00:58,820
文字列内のこれらの要素の1つを次にこのように再割り当てしようとします。

17
00:00:58,820 --> 00:01:02,510
文字列はPythonではそのように動作しません。

18
00:01:02,510 --> 00:01:04,580
&nbsp;

19
00:01:04,580 --> 00:01:09,960
&nbsp;

20
00:01:09,960 --> 00:01:15,630
後で、アイテムの割り当てをサポートする他のデータ型について説明します。これは、これを再割り当てする場合、基本的に新しい文字列を作成する必要があり、連結で行うことができるということです。

21
00:01:15,840 --> 00:01:17,070
&nbsp;

22
00:01:17,070 --> 00:01:22,170
これは2つの文字列を一緒にマージするようなものなので、これをコメントして、ハッシュタグをその前に置くコメントを作成します。これを実行すると何も出ません。

23
00:01:22,170 --> 00:01:25,860
だから基本的に何かハッシュタグは、実行されないコメントされたコードだけです。

24
00:01:25,860 --> 00:01:30,420
私たちがすでに名前について持っているものを使ってPamという文字列を作成しようとしているこの例を見てみましょう。

25
00:01:30,490 --> 00:01:37,060
だから最初にやりたいのは、とmをつかむことです。

26
00:01:37,060 --> 00:01:41,090
それで、以前学習したスライス表記法を使ってみましょう。

27
00:01:41,260 --> 00:01:44,760
私たちはインデックス1から始め、最後まで最後まで行くつもりです。

28
00:01:44,830 --> 00:01:48,970
だからそれをチェックしよう。

29
00:01:48,970 --> 00:01:49,990
それで完璧です。

30
00:01:50,200 --> 00:01:52,100
それで、最後の手紙のようなものにこれを署名するのは、終わりまでのすべての方法と同じです。

31
00:01:52,120 --> 00:02:01,030
だから、最後の文字をもう一度見たら、タブを使ってオートコンプリートすることができます。

32
00:02:01,030 --> 00:02:04,510
Plusの最後の文字を言うことができます。

33
00:02:04,510 --> 00:02:11,980
ここでAMと言いますが、今私ができることは2つの最後の文字を連結することができるということです。あなたがそれを行う方法はプラス記号で終わるので、P

34
00:02:12,070 --> 00:02:20,940
これは文字列連結として知られています。

35
00:02:20,950 --> 00:02:22,960
さらにいくつかの例を探そう。

36
00:02:23,230 --> 00:02:25,260
私はxがHello Worldと等しいと言うつもりです。

37
00:02:25,270 --> 00:02:31,050
そして、私はXプラスが美しいと言うことができます。

38
00:02:33,360 --> 00:02:39,240
私はこれを実行すると、私はハローの世界を見ることができます。

39
00:02:40,290 --> 00:02:44,040
外は綺麗です。

40
00:02:44,040 --> 00:02:45,420
&nbsp;

41
00:02:45,510 --> 00:02:49,770
心の中に留めておくべきことは、ここにはスペースがないことです。なぜなら、世界の終わりにはスペースがなく、その冒頭にスペースがないからです。

42
00:02:49,770 --> 00:02:52,120
だからそこに少しスペースを入れるといいだろう。

43
00:02:52,320 --> 00:02:54,620
だからあなたはこれをもう一度やり直すとき。

44
00:02:54,630 --> 00:02:56,930
外は綺麗です。

45
00:02:56,940 --> 00:02:58,770
&nbsp;

46
00:02:58,770 --> 00:03:05,310
今私は再割り当てでこれを複数回行うと、xがxと等しいと言うことができるので、それは外で美しいです。

47
00:03:05,310 --> 00:03:06,390
今私はこれを実行したい私は今見つけることができるので、私はXを見つける読んだ。

48
00:03:06,390 --> 00:03:09,290
こんにちは世界。

49
00:03:09,300 --> 00:03:09,810
外は綺麗です。

50
00:03:09,810 --> 00:03:11,140
私が偶然、このセルを複数回走らせた場合、私はそれを美しい外に追加します。

51
00:03:11,220 --> 00:03:16,090
もう一度。

52
00:03:16,110 --> 00:03:16,740
だから私はこれをもう一度実行します。

53
00:03:16,740 --> 00:03:18,000
Hello worldと書かれているセルのすぐ隣で何個の数字が変更されるのかを確認します。

54
00:03:18,090 --> 00:03:22,080
外は綺麗です。

55
00:03:22,080 --> 00:03:22,890
それは外で美しいですし、私たちはこれを続けていくことができます。

56
00:03:22,890 --> 00:03:26,840
これは文字列連結であり、文字列をすばやくまとめることができます。

57
00:03:26,900 --> 00:03:32,360
一度に複数のストリングデトネーションを行うこともできます。

58
00:03:32,370 --> 00:03:38,250
私はそれがどのように見えるかを教えてあげましょう。

59
00:03:38,250 --> 00:03:39,590
これまではプラス記号を使用して2つの文字列を連結したり、それらを結合したりしていました。

60
00:03:39,770 --> 00:03:44,610
しかし、あなたがZと等しい文字を持っていて、あなたがKuechlyが10のZeeseを望んでいたら、Letter

61
00:03:44,820 --> 00:03:52,600
times 10と言うことができます。

62
00:03:53,270 --> 00:03:54,290
そこにあなたが見ることができました。

63
00:03:54,650 --> 00:03:55,880
ここで寝る人は簡単に10回簡単です。

64
00:03:56,000 --> 00:03:58,650
だからそれは文字の乗算を使用しているし、それは文字のプラス記号を使用しています。

65
00:03:58,880 --> 00:04:03,800
&nbsp;

66
00:04:03,950 --> 00:04:09,140
文字列デトネーションや文字列の乗算を行うときに、文字列と数値を連結しようとするとエラーが発生することに注意してください。

67
00:04:09,260 --> 00:04:13,790
私が2 + 3をやっていると想像していることをお見せしたい。

68
00:04:13,790 --> 00:04:18,600
私たちはこれを実行し、5を得る。

69
00:04:18,660 --> 00:04:19,880
私たちが文字列理論に加えて文字列に行うのなら、それは意味があります。

70
00:04:19,880 --> 00:04:25,740
今は文字列であるため、それらを一緒に追加することはありません。

71
00:04:26,030 --> 00:04:28,520
代わりに連結を実行する予定です。

72
00:04:28,520 --> 00:04:30,730
&nbsp;

73
00:04:30,740 --> 00:04:37,820
そこでここでは文字列23を返します。これは動的な型定義のコールバックであり、ここではデータ型を本当に注意する必要がありました。

74
00:04:37,820 --> 00:04:39,650
&nbsp;

75
00:04:39,680 --> 00:04:44,780
だから、この種の問題を念頭に置いて、あなたのユーザは文字列を入れてしまい、その後はコードを書くことになるかもしれません。

76
00:04:44,780 --> 00:04:45,460
それらを一緒に追加すると、5の代わりに23のような予期しない結果に終わることがあります。

77
00:04:45,560 --> 00:04:51,240
これは、Pythonの柔軟性に優れていることと悪い点の両方を示す非常に優れた例です。ここではエラーが発生していないという柔軟性がありますが、多少柔軟性があります。

78
00:04:51,320 --> 00:04:58,070
23。

79
00:04:58,070 --> 00:05:02,570
&nbsp;

80
00:05:02,720 --> 00:05:05,480
&nbsp;

81
00:05:05,600 --> 00:05:10,070
後で、こうした種類の間違いやエラーを防止するために、もっと多くの方法について学習します。

82
00:05:10,070 --> 00:05:11,080
組み込みの文字列メソッドをいくつか議論してみましょう。

83
00:05:11,480 --> 00:05:14,630
&nbsp;

84
00:05:14,840 --> 00:05:20,150
&nbsp;

85
00:05:20,150 --> 00:05:24,260
ですから、Pythonのオブジェクトは通常、組み込みのメソッドを持っています。これらのメソッド自体は本質的にオブジェクトの内部にある関数であり、後で独自のメソッドで独自の関数を作成する方法を学びます。

86
00:05:24,290 --> 00:05:25,350
今すぐ、いくつかの便利な方法を見て行きましょう。

87
00:05:25,470 --> 00:05:29,620
私は新しい文字列を作成して、それをXと呼んで、Helloの世界を言いましょう。

88
00:05:29,630 --> 00:05:37,150
&nbsp;

89
00:05:38,610 --> 00:05:46,460
私がXドットを押してからタブを押すと、このリストがJupiterのノートブックにポップアウトされているはずです。これはこの文字列オブジェクトで利用できるすべての属性とメソッドのリストです。

90
00:05:46,460 --> 00:05:51,540
もう一度Xを定義したら、何も表示されません。

91
00:05:51,540 --> 00:05:55,240
だから、あなたがX

92
00:05:55,290 --> 00:06:00,630
hello worldと言うセルを走らせてから、新しいセルがタブを押すXと言うなら、このリストを見るべきです。

93
00:06:00,630 --> 00:06:02,020
あなたが見ることができるように、ここにはたくさんのメソッドがあり、今はそれらのすべてを調べるつもりはありません。

94
00:06:02,110 --> 00:06:06,240
このコースの後半で使用する最も有用なものを紹介します。

95
00:06:06,270 --> 00:06:10,440
&nbsp;

96
00:06:11,250 --> 00:06:17,940
文字列内のすべてを大文字で大文字にすると、上カッコと上カッコを閉じることができ、文字列内のすべてを大文字にすることができます。

97
00:06:17,940 --> 00:06:20,130
この方法は適切ではないことに注意してください。

98
00:06:20,130 --> 00:06:23,120
つまり、実際には元の文字列には影響しません。

99
00:06:23,130 --> 00:06:26,380
元の文字列に影響を与えたくない場合は、再割り当てする必要があります。

100
00:06:26,520 --> 00:06:29,410
あなたは何かのようにする必要があります。

101
00:06:29,410 --> 00:06:30,210
XはXの上位バージョンの場合と同じです。 だから心に留めておいてください。

102
00:06:30,240 --> 00:06:34,230
元のx文字列が必要なので、今すぐ実行しようとしています。誤って再割り当てを行った場合は、常に実行と言うことができます。

103
00:06:34,320 --> 00:06:35,000
&nbsp;

104
00:06:35,010 --> 00:06:39,560
こんにちは世界。

105
00:06:39,570 --> 00:06:41,220
大丈夫。

106
00:06:41,220 --> 00:06:42,760
だから間違いのように初心者の方にとっては上手な方法があります。間違いなく上手くやっていて、かっこと閉じ括弧を忘れてしまうからです。

107
00:06:42,870 --> 00:06:43,270
&nbsp;

108
00:06:43,470 --> 00:06:48,330
そして、これを実行すると、これは関数文字列の上にあり、基本的にはPythonが言っているのですか？ああ、あなたはまだこのメソッドや関数を実行していません。

109
00:06:48,330 --> 00:06:52,670
&nbsp;

110
00:06:52,710 --> 00:06:58,650
代わりに、あなたはそれが何であるか私に尋ねました。

111
00:06:58,740 --> 00:07:03,100
だから、あなたが開かれた王子なしでそれを呼び出すと、このように見える何かが得られると、実際にその方法や機能が実行されていないことを意味します。

112
00:07:03,240 --> 00:07:05,520
&nbsp;

113
00:07:05,730 --> 00:07:10,050
代わりに、あなたはちょうどちょっとPythonにちょっと質問します。これは、上のメソッドがあるからです。

114
00:07:10,050 --> 00:07:13,690
ここにあるすべての文字を小文字にするIloriメソッドもあります。

115
00:07:13,980 --> 00:07:19,540
HとWは小文字です。

116
00:07:19,560 --> 00:07:23,260
次にsplitメソッドもあり、splitメソッドを使うと文字列のリストを素早く作成することができます。

117
00:07:23,310 --> 00:07:26,500
&nbsp;

118
00:07:26,530 --> 00:07:34,090
だからここで私たちはこんにちはと世界を持っていると言うことができます。

119
00:07:34,090 --> 00:07:34,800
今、私たちは本当にリストをまだ議論していないが、彼らは来ている。

120
00:07:35,670 --> 00:07:38,860
だから私が今思っておきたいのは、私がその分割を使用すると、その空白に基づいて文字列を分割するか、またはあなたが編集した文字に基づいて文字列を分割するということです。

121
00:07:38,910 --> 00:07:41,770
&nbsp;

122
00:07:41,820 --> 00:07:48,450
だから私がそれを意味するものをあなたに見せてあげましょう。

123
00:07:48,450 --> 00:07:51,820
だから私はxは等しいと言うでしょう。

124
00:07:51,840 --> 00:07:53,660
&nbsp;

125
00:07:53,940 --> 00:07:56,170
こんにちはこれは文字列を実行していると私はXの分割を私はすべての空白に分割して取得すると言う私は高い得る。

126
00:07:56,510 --> 00:07:59,580
これはリストの中にうまく編成された文字列です。

127
00:08:03,060 --> 00:08:10,630
しかし、私は分割したい文字列を渡すことができます。

128
00:08:10,650 --> 00:08:14,060
だから、デフォルトでは分割は空白で分割されますが、実際にはそれを分割することができます。

129
00:08:14,070 --> 00:08:19,350
だから私はそれを分割するつもりです。

130
00:08:19,560 --> 00:08:25,170
だから私がこれを実行すると面白い結果が得られるはずです。

131
00:08:25,350 --> 00:08:27,970
&nbsp;

132
00:08:28,050 --> 00:08:31,100
そして、それは本質的にすべての私のそれを分割しているので、他の空白が含まれています。

133
00:08:31,440 --> 00:08:35,130
だから私はHを取得しているので、いずれかがあります。

134
00:08:35,130 --> 00:08:35,810
それはそれを取り除き、次の空間になるまですべてを得る。

135
00:08:36,030 --> 00:08:38,260
それから、X Iまですべてを取得します。

136
00:08:38,310 --> 00:08:42,780
それはS空間であり、それはここにある、そして再びそうである。

137
00:08:42,960 --> 00:08:45,900
他の私と弦楽器の大きな部分はIです。

138
00:08:45,960 --> 00:08:49,880
そして、N-G。

139
00:08:49,910 --> 00:08:53,950
ですから、splitを使って文字列からリストを素早く作成する方法です。そして、後ほどOKでさらに詳細にリストを扱います。

140
00:08:53,970 --> 00:08:54,990
&nbsp;

141
00:08:54,990 --> 00:08:59,880
次に、印刷のための文字列の書式について説明します。

142
00:08:59,880 --> 00:09:03,320
文字列に沿って他のオブジェクトを素早く印刷するのに便利な方法がたくさんあります。

143
00:09:03,490 --> 00:09:07,900
&nbsp;

144
00:09:07,900 --> 00:09:13,870
これまでのところ、基本的な機能としてプリントを使用する方法を学んだだけでなく、プリントすることもできますが、実際には見たことのないプリント機能やフォーマット方法の方がはるかに優れています。

145
00:09:13,870 --> 00:09:18,640
それでは、次の講義でそれが見えることを説明しましょう。

146
00:09:18,640 --> 00:09:23,800
&nbsp;

147
00:09:23,800 --> 00:09:26,820
&nbsp;
