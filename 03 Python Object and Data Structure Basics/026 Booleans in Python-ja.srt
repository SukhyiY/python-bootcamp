1
00:00:05,520 --> 00:00:07,260
ねえ、彼らはこの講義を歓迎します。

2
00:00:07,260 --> 00:00:13,170
基本的に、真偽または偽のいずれかのステートメントを運ぶ演算子に使用する用語であることに慣れていない場合のために、ブール値ブール値について簡単に説明します。

3
00:00:13,230 --> 00:00:17,700
&nbsp;

4
00:00:17,730 --> 00:00:22,200
そして、これらは後で、制御フローとロジックを感じるときには本当に重要です。特定の条件が発生したかどうかを何度も確認したいからです。

5
00:00:22,470 --> 00:00:24,900
&nbsp;

6
00:00:25,050 --> 00:00:29,910
言い換えれば、特定の条件を満たしていれば、コードを実行することができます。たとえば、私のプールが空であることを確認することができます。

7
00:00:29,910 --> 00:00:32,940
&nbsp;

8
00:00:33,000 --> 00:00:38,720
それが真実ならば、プールやその自然のものをいっぱいにするために水をつけてください。

9
00:00:38,730 --> 00:00:41,540
だからこそ、ブーリンはたくさんのタイタンで本当に重要です。

10
00:00:41,550 --> 00:00:44,730
私たちは、真実と偽という言葉で直接外国人を扱うことはありません。

11
00:00:44,770 --> 00:00:49,720
実際には、比較演算子と論理演算子を使用してブール値を返します。

12
00:00:49,920 --> 00:00:52,590
だから、これらが実際にどのように見えるかを非常に素早く見てみましょう。

13
00:00:52,590 --> 00:00:54,270
そして、後でそれらを探検します。

14
00:00:54,260 --> 00:00:57,420
そして、彼らが私たちにとってより有用になったときには、もっと詳しく説明します。

15
00:00:57,420 --> 00:00:59,180
木星に今すぐ行きましょう。

16
00:00:59,610 --> 00:01:05,640
何十億もの人々が真実と偽りがあります。そして、Pythonでは、それが真実であるために大文字にしたことを確かめる必要があります。

17
00:01:05,650 --> 00:01:07,850
&nbsp;

18
00:01:07,890 --> 00:01:10,610
それ以外の場合は、小文字のtがある場合は、ただ文句を言うでしょう。

19
00:01:10,660 --> 00:01:16,190
Hey Eithanは、あなたが変数を代わりに呼び出していると考えるので、この用語を真と定義します。

20
00:01:16,200 --> 00:01:19,290
彼らはCを大文字にしていることを確認し、それは偽に対しても同じです。

21
00:01:19,290 --> 00:01:21,480
Fを大文字にする必要があります。

22
00:01:21,540 --> 00:01:22,690
だから、ここには真実と偽りがある。

23
00:01:22,710 --> 00:01:27,260
平均ブール値とタイプを言って彼らのタイプを確認することができます。

24
00:01:27,300 --> 00:01:33,390
そのTタイプを大文字にすることを偽ってください。そして、数十億ドルのBOLは、私たちがやろうとしている多くの時間に論理コードを扱っているときに対処しようとしているものです。ブール値を作成して、このコースの後のすべての比較演算子について説明しますが、非常に簡単な例を示します。

25
00:01:33,390 --> 00:01:37,590
&nbsp;

26
00:01:37,680 --> 00:01:42,900
&nbsp;

27
00:01:42,900 --> 00:01:46,180
&nbsp;

28
00:01:46,320 --> 00:01:50,790
比較演算子は、何かが他のものよりも大きいかどうかをチェックするので、heyが2より大きいと言うことができます。

29
00:01:50,820 --> 00:01:53,130
&nbsp;

30
00:01:53,170 --> 00:01:57,080
そこには単純な数学的表現があり、それはfalseでpackableを返します。

31
00:01:57,120 --> 00:01:58,720
1つは2つ以下です。

32
00:01:58,890 --> 00:02:03,060
そして、等号の代わりに2つの等号で平等をチェックするようなことができます。

33
00:02:03,060 --> 00:02:03,800
&nbsp;

34
00:02:03,990 --> 00:02:05,470
したがって1に等しい1。

35
00:02:05,640 --> 00:02:07,760
それを実行するとtrueを返します。

36
00:02:07,800 --> 00:02:12,020
したがって、これらは比較演算子Ellabyと呼ばれ、このコースの後半ですべてを表示します。

37
00:02:12,150 --> 00:02:16,380
しかし、まず彼らが実際に何を返すのかをブーリアンで伝えなければなりません。

38
00:02:16,440 --> 00:02:22,200
大丈夫ですので、それらは単に真実と偽であり、タイプはb oです。このコースでは後で批判的になるでしょう。

39
00:02:22,200 --> 00:02:24,060
&nbsp;

40
00:02:24,150 --> 00:02:29,640
最後に、私たちがまだ割り当てたくないオブジェクトのプレースホルダーとしてnoneキーワードを使用できることを言いたいと思います。

41
00:02:29,640 --> 00:02:30,930
&nbsp;

42
00:02:31,110 --> 00:02:34,570
だから後で私は私のコードの中に何かにBを割り当てたい。

43
00:02:34,590 --> 00:02:38,100
しかし、今私はちょうどそれのためのプレースホルダーを持っている必要がありますので、私はこのエラーを取得しません。

44
00:02:38,130 --> 00:02:39,590
ちょっとBは罰金ではありません。

45
00:02:39,780 --> 00:02:42,010
私ができることは、Bはnoneと等しいと言うことです。

46
00:02:42,240 --> 00:02:45,330
首都とそこにはそれがない彼らのタイプです。

47
00:02:45,330 --> 00:02:49,920
そして、私たちは実際には、以前のところ、私たちが最善の方法でその方法を扱っていたことを見てきました。

48
00:02:49,920 --> 00:02:53,440
リストを並べ替えると、リストは返されなかったことを忘れないでください。

49
00:02:53,460 --> 00:02:55,730
だからここにBとタイプすると何も見えません。

50
00:02:55,920 --> 00:02:56,760
しかし、何がいいですか。

51
00:02:56,760 --> 00:02:59,430
彼らはまた、それが見つからないという誤りを見ない。

52
00:02:59,830 --> 00:03:01,800
OKは本当にブール値の基本です。

53
00:03:01,800 --> 00:03:05,640
私たちはこのコースの後半でこれをさらに進めるつもりです。

54
00:03:05,640 --> 00:03:06,540
私は次の講義があるかどうかを見ていきます。
