1
00:00:05,680 --> 00:00:06,760
みんなを歓迎します。

2
00:00:06,760 --> 00:00:08,760
今度は辞書について話す時間です。

3
00:00:09,670 --> 00:00:13,270
辞書は、オブジェクトを格納するための順序付けられていないマッピングです。

4
00:00:13,270 --> 00:00:16,980
以前は、リストを使って順序付けられた順序でオブジェクトを格納する方法を見てきました。

5
00:00:17,260 --> 00:00:22,050
しかし今や辞書は、代わりにキー値のペアリングとして知られているものを使って姉妹オブジェクトを許可します。

6
00:00:22,270 --> 00:00:27,660
また、このキー値のペアを使用すると、ユーザーは正確なインデックス位置を知る必要なく、オブジェクトをすばやく取得できます。

7
00:00:27,670 --> 00:00:28,250
&nbsp;

8
00:00:28,300 --> 00:00:32,500
キーを呼び出すだけで、そのキーに関連付けられた値が返されます。

9
00:00:33,920 --> 00:00:39,710
また、辞書構文では、中括弧とコロンを使用して、キーと関連する値の間の関係を示します。

10
00:00:39,710 --> 00:00:41,030
&nbsp;

11
00:00:41,210 --> 00:00:46,570
だからここで中括弧を見ることができますし、文字列キーを持っていますので、石炭をキーし、それに関連する値は何ですか？

12
00:00:46,570 --> 00:00:48,430
&nbsp;

13
00:00:48,470 --> 00:00:53,720
この場合、値1と呼ばれる文字列があるだけです。次に、次のキー値のペアのコンマがあります。

14
00:00:53,720 --> 00:01:00,130
今質問はいつ私達がリストを選ぶか、いつ私達が辞書を選ぶかよく辞書はキー名によって取り出されたオブジェクトを持ち、辞書は順序付けされておらず、並べ替えることができない。

15
00:01:00,130 --> 00:01:05,420
&nbsp;

16
00:01:05,590 --> 00:01:11,200
したがって、正確なインデックスの位置を知る必要なしに、値をすばやく検索する場合は、辞書を使用するのがよいでしょう。

17
00:01:11,200 --> 00:01:13,810
&nbsp;

18
00:01:13,810 --> 00:01:15,840
これは辞書の本当に素晴らしい機能です。

19
00:01:15,880 --> 00:01:19,200
あなたが何かが実際の辞書にどこにあるのかを知る必要はないという事実。

20
00:01:19,240 --> 00:01:21,200
キー値のペアを知っているだけです。

21
00:01:21,280 --> 00:01:26,770
ただし、辞書にはキー値マッピングがあるため、辞書をソートできないという問題があります。

22
00:01:26,770 --> 00:01:28,080
&nbsp;

23
00:01:28,090 --> 00:01:33,390
それは、それが最も効率的だと思われる場所に新しいキー値ペアを挿入することを意味します。

24
00:01:33,600 --> 00:01:39,520
一方、リストは位置に基づいてオブジェクトを達成できるので、実際のリストをスライスして並べ替えることができます。

25
00:01:39,520 --> 00:01:42,250
&nbsp;

26
00:01:42,250 --> 00:01:44,980
したがって、辞書を使用すると、その機能を失うことはありません。

27
00:01:45,130 --> 00:01:49,240
&nbsp;

28
00:01:49,450 --> 00:01:54,390
したがって、基本的には、キーバリューのペアを使用して辞書から何かを呼び出して取得することが容易になり、物事を並べ替えるか、インデックスの位置を失うことになります。

29
00:01:54,400 --> 00:01:55,030
&nbsp;

30
00:01:55,390 --> 00:01:59,520
さて、木星ノートにジャンプして、これらの概念をもう少し詳しく調べてみましょう。

31
00:01:59,920 --> 00:02:03,350
辞書を構築する方法を説明しましょう。

32
00:02:03,370 --> 00:02:07,440
私たちは、オブジェクトの作成や作成を始めます。

33
00:02:07,480 --> 00:02:13,610
私の辞書は中括弧を持ち、キーを定義するので、キーは文字列でなければなりません。

34
00:02:13,610 --> 00:02:14,810
&nbsp;

35
00:02:14,840 --> 00:02:15,960
だから重要なもの。

36
00:02:15,980 --> 00:02:18,590
そして、私たちはその鍵の関連する価値を持っています。

37
00:02:18,590 --> 00:02:20,700
今のところ私は基本的な文字列に固執します。

38
00:02:20,760 --> 00:02:24,560
次に、コンマがあり、新しいキー値のペアを挿入できます。

39
00:02:24,750 --> 00:02:28,410
だからコロンと別の値です。

40
00:02:28,620 --> 00:02:30,310
OKだからここに辞書があります。

41
00:02:31,470 --> 00:02:34,940
そして、私たちがそれを返すと、私たちは辞書全体を得ることになります。

42
00:02:35,070 --> 00:02:38,240
しかし、実際に私たちがしたいことは、辞書から値を取得することです。

43
00:02:38,490 --> 00:02:43,250
したがって、インデックスの場所を使用する代わりに、同じ角括弧を使用します。

44
00:02:43,260 --> 00:02:46,370
しかし今、価値を取り戻すために、私たちは鍵を渡します。

45
00:02:46,420 --> 00:02:52,380
その値を関連づけて、辞書がQ Oneを渡していると言うことができるようにして、その値自体を取り戻しましょう。

46
00:02:52,380 --> 00:02:54,930
したがって、辞書のユースケースの良い例です。

47
00:02:54,940 --> 00:03:00,190
たぶん店の価格のようなものなので、私は価格と呼ばれる辞書を持っていると言うことができます。

48
00:03:00,190 --> 00:03:02,170
我々はそれを価格と呼ぶことさえできる。

49
00:03:02,190 --> 00:03:04,840
私たちはこの価格を持っているので、ルックアップ。

50
00:03:04,840 --> 00:03:10,240
ルックアップ辞書とアップルなどの辞書にさまざまな項目を追加することができますし、それらの関連する価格ので、我々はリンゴと言うでしょう。

51
00:03:10,240 --> 00:03:12,520
&nbsp;

52
00:03:12,760 --> 00:03:18,370
私は$ 2と99セントが多分それが価格で作られていないものであればポンド当たりのことは知らない。

53
00:03:18,550 --> 00:03:26,800
私たちは、それらが1 9

54
00:03:26,830 --> 00:03:28,960
9であることができるオレンジを持つことはできませんし、チョコレートミルクやミルクの種類を言うことができます。

55
00:03:28,990 --> 00:03:33,490
そして、それは$ 5と80セントの価格を持つつもりです。

56
00:03:33,560 --> 00:03:34,490
そしてそこに行く。

57
00:03:34,490 --> 00:03:39,000
だから、私の辞書やこの辞書は、巨額の価格になる可能性があります。

58
00:03:39,080 --> 00:03:41,660
私はちょうどリンゴの価格はちょっと知りたいと思うだろう。

59
00:03:41,720 --> 00:03:44,450
私はそれを実行するリンゴを渡すと、それは戻って戻ってくる。

60
00:03:44,450 --> 00:03:45,440
実際の価格。

61
00:03:45,500 --> 00:03:48,380
それでは、インデックスの場所を知る必要があります。

62
00:03:48,410 --> 00:03:53,810
私は簡単にこれらのオブジェクトの価格をキー値のペアを使って得ることができます。

63
00:03:53,870 --> 00:03:58,240
だから、リストのようなものではなく、辞書が必要な理由の本当に良い例です。

64
00:03:58,250 --> 00:04:02,840
ここでは、私はお互いに関連づけたいと思う2つの値を持っているので、そのキーを与えられた値をすばやく調べます。

65
00:04:02,840 --> 00:04:05,540
&nbsp;

66
00:04:05,550 --> 00:04:09,510
ここで重要なのは、辞書は実際には保持できるデータ型の柔軟性が非常に高いことです。

67
00:04:09,510 --> 00:04:10,230
&nbsp;

68
00:04:10,230 --> 00:04:16,410
文字列だけでなく整数や浮動小数点数をどのように保持できるかを示したが、実際にリストや他の辞書を保持することもできる。

69
00:04:16,410 --> 00:04:19,220
&nbsp;

70
00:04:19,440 --> 00:04:28,520
だから私はちょうど例としてDが等しいと言って、k 1を鍵に等しくし、1から3までの数を持つことができる、あるいは私ができることはK-2と言うことができます。これに関連するリストがあるので、私は0

71
00:04:29,180 --> 00:04:35,210

72
00:04:35,210 --> 00:04:42,620
2と言うことができ、次にこの辞書の中で別の辞書を実行することもできます。

73
00:04:42,620 --> 00:04:43,610
&nbsp;

74
00:04:43,610 --> 00:04:45,800
これはそれほど一般的ではありませんが、サポートされています。

75
00:04:46,130 --> 00:04:52,960
だからここに100という数字があるキーの中に言うことができる。

76
00:04:53,010 --> 00:04:56,060
したがって、辞書自体はこれをすべて扱うことに問題はありません。

77
00:04:56,130 --> 00:05:01,560
そして、私たちがこの要素をつかみたいのであれば、私が過去と呼んでいたこのリスト0 1

78
00:05:01,560 --> 00:05:04,000
2をつかみたいと思います。

79
00:05:04,170 --> 00:05:06,050
&nbsp;

80
00:05:08,940 --> 00:05:11,130
K-2とこのケースはこれを実行し、リストを返す文字列でなければなりません。

81
00:05:11,130 --> 00:05:17,400
そして、もし私がこの番号100をつかみたいのであれば、そのK3の関連するキーを見つけることができます。

82
00:05:17,460 --> 00:05:19,790
&nbsp;

83
00:05:19,990 --> 00:05:22,330
それを実行すると、この辞書を取り戻すことができます。

84
00:05:22,330 --> 00:05:24,920
だから私はこのすべてをもう一度呼び出すことができます。

85
00:05:24,970 --> 00:05:28,890
だから私はちょうどそれを実行する洞察キーコピーを言うことができ、その後私は100に戻る。

86
00:05:32,460 --> 00:05:34,710
&nbsp;

87
00:05:34,740 --> 00:05:35,960
ここで何が起こっているのか注目してください。

88
00:05:35,970 --> 00:05:41,580
そして、基本的にインデックス呼び出しまたはキー呼び出しを積み重ねて、私が望む値を取得します。

89
00:05:41,610 --> 00:05:44,880
だから私はここで2番をつかみたいと考えてみましょう。

90
00:05:45,090 --> 00:05:51,580
私がする必要があるのは、リストを返すd k 2と言います。そして、アイテムインデックスも必要です。

91
00:05:51,630 --> 00:05:59,800
だから、私はちょうど2つを言うことができたし、私は戻って取得し、この全体が少し前に混乱することができます。

92
00:05:59,800 --> 00:06:00,300
&nbsp;

93
00:06:00,310 --> 00:06:03,960
ですから、これが明確であることを確かめるためにもう1つの例を見てみましょう。

94
00:06:04,040 --> 00:06:13,460
&nbsp;

95
00:06:15,800 --> 00:06:22,890
&nbsp;

96
00:06:22,890 --> 00:06:25,330
私は言うだろう私の辞書はキーを持っていて、このキーが小文字のリストであれば関連付けるABC私は私の辞書のキーABCをチェックして、先に進み、Cという文字をつかんで大文字にしてみよう文字列。

97
00:06:25,350 --> 00:06:28,230
私ができることは、さまざまなステップを経て次のことをすることです。

98
00:06:28,230 --> 00:06:34,590
私は私のリストが重要なものと等しいと言うことができます。

99
00:06:34,590 --> 00:06:36,980
そして私が私のリストをチェックすれば私はそれを持っています。

100
00:06:37,020 --> 00:06:43,220
私が手紙が私のリストのインデックスの場所2と等しいと言うことができるように。

101
00:06:43,620 --> 00:06:51,130
そして、私が私の手紙をチェックすると、Letterを大文字にしてから、私は大文字のCを持っています。

102
00:06:51,160 --> 00:06:53,020
私がやったすべてのステップがここにあるように。

103
00:06:53,170 --> 00:06:58,810
私は最初にキーをつかんでリストにした後、そのリストを索引付けしてその手紙をつかんで、大文字でその手紙を言った。

104
00:06:58,810 --> 00:07:01,330
&nbsp;

105
00:07:01,450 --> 00:07:07,150
しかし、私は実際にこれをすべて一歩一歩進めることができます。なぜなら、柔軟性のあるPythonがリストを返すキーをつかむことができるからです。

106
00:07:07,150 --> 00:07:10,090
&nbsp;

107
00:07:10,300 --> 00:07:12,220
だから、これはしばしば再割り当てのようなものです。

108
00:07:12,280 --> 00:07:13,300
私はちょうど電話を続けます。

109
00:07:13,300 --> 00:07:17,350
私は何を望んでいて、私は文字Cを持つためにインデックスを作成したい

110
00:07:17,440 --> 00:07:24,740
そして今これは私がアッパーと呼ぶことができる文字列であり、大文字のCを持っていますので、このようにすることもできます。

111
00:07:24,740 --> 00:07:25,460
&nbsp;

112
00:07:25,460 --> 00:07:31,100
&nbsp;

113
00:07:31,160 --> 00:07:37,630
これらの手順のそれぞれを行う代わりに、このようなことを頻繁にやることはありませんが、辞書の力を活用してリストを保持することがあります。

114
00:07:38,150 --> 00:07:38,360
OK。

115
00:07:38,370 --> 00:07:39,810
だから私はあなたがそれを知って欲しいだけです。

116
00:07:39,840 --> 00:07:48,050
新しいキー値のペアを辞書に追加したい場合は、単体オブジェクトのようなスタック呼び出しを行うことができます。

117
00:07:48,050 --> 00:07:48,710
&nbsp;

118
00:07:48,710 --> 00:07:50,450
それはかなり簡単です。

119
00:07:50,660 --> 00:07:52,490
だからここで新しい辞書を作ってみましょう。

120
00:07:53,330 --> 00:08:03,200
記録はK-1が100で、K-2が200であると言うでしょう。

121
00:08:03,200 --> 00:08:09,560
だから私の辞書K-1とK-2は、私がK3が300を加えたかったと想像してみましょう。

122
00:08:09,590 --> 00:08:14,780
その場合、私がする必要があるのは、新しい鍵を割り当てることです。

123
00:08:14,780 --> 00:08:19,550
だからK-3を300に設定してください。

124
00:08:19,780 --> 00:08:24,180
そして、私が辞書を見てみると、今私はK3 300を持っています。

125
00:08:24,180 --> 00:08:27,760
これで、新しいキー値のペアを辞書に追加する方法を見てきました。

126
00:08:27,760 --> 00:08:32,220
同じ方法を使用して、既存のキー値ペアを簡単に上書きすることもできます。

127
00:08:32,440 --> 00:08:36,820
k 1のdを言い、それを新しい値に設定することができます。

128
00:08:36,820 --> 00:08:41,400
だからそれを本当に明白にするために、そこに新たな文字列を追加し、次にDと呼んでk 1を見てみましょう。

129
00:08:41,410 --> 00:08:42,110
&nbsp;

130
00:08:42,160 --> 00:08:45,250
今、それに関連する新しい価値があります。

131
00:08:45,250 --> 00:08:49,630
最後に、いくつかの便利な辞書の方法について議論したいと思います。それらは辞書の項目のすべてのキー値を取得する方法です。

132
00:08:49,630 --> 00:08:52,110
&nbsp;

133
00:08:52,300 --> 00:08:53,520
だから今は辞書があります。

134
00:08:53,530 --> 00:08:56,740
K-1 K-2 K-3新しい値200または300。

135
00:08:56,950 --> 00:08:59,010
私はそれを古いものになるように再割り当てするつもりです。

136
00:08:59,030 --> 00:09:02,090
だから私はこれをここにコピーしてDと言うことにする。

137
00:09:02,170 --> 00:09:04,940
その辞書のバージョンと等しいです。

138
00:09:05,200 --> 00:09:11,850
辞書のすべてのキーを見たい場合は、Dキーと言うことができます。逆の場合は、すべての実際のキーを返します。

139
00:09:11,850 --> 00:09:14,220
&nbsp;

140
00:09:14,220 --> 00:09:15,320
そして、私はすべての価値が欲しい。

141
00:09:15,390 --> 00:09:21,060
&nbsp;

142
00:09:21,090 --> 00:09:27,840
私がする必要があるのは、ドットの値を返してから値を返すだけです。実際のペアリングを一緒にしたい場合は、Deedatのアイテムを開いてプリンスを開いて、それらを一緒に実行してペアを返すと言うことができます。

143
00:09:27,840 --> 00:09:28,290
&nbsp;

144
00:09:28,290 --> 00:09:32,330
OKは100から200に上がり、K3は300で行く。

145
00:09:32,520 --> 00:09:34,900
そしてこれらはあなたが気づくでしょう実際にカッコ内にあります。

146
00:09:35,100 --> 00:09:38,880
そして、これは実際にあなたがすぐに学ぶことになるタプルであることを意味します。

147
00:09:39,390 --> 00:09:39,620
OK。

148
00:09:39,630 --> 00:09:41,330
それは本当に辞書の基本です。

149
00:09:41,340 --> 00:09:44,150
私たちがちょうど学んだことの非常に簡単な概要。

150
00:09:44,160 --> 00:09:47,650
辞書の主な構文は中括弧で定義されています。

151
00:09:47,670 --> 00:09:50,940
あなたは文字列のコロンと値を持っています。

152
00:09:51,000 --> 00:09:54,150
そして、Pythonは、この価値ができるものは本当に柔軟です。

153
00:09:54,150 --> 00:09:59,650
これは、リスナー辞書の浮動小数点数の整数などの別の文字列にすることができます。

154
00:09:59,660 --> 00:10:04,680
そのキーの値のペアを持つことができます。そして、それらをコンマで区切ります。キー自体は常に文字列でなければなりません。

155
00:10:04,680 --> 00:10:06,200
&nbsp;

156
00:10:06,370 --> 00:10:10,180
そして、我々は簡単に見上げるだけで物事を見ることができます。

157
00:10:10,180 --> 00:10:15,160
ここでも、インデックスを過去とキー自体に渡すことを除いて、以前に見たのと同じブラケット表記を使用しています。

158
00:10:15,160 --> 00:10:17,970
&nbsp;

159
00:10:18,010 --> 00:10:25,330
また、キーとメソッドの呼び出しを基本的に積み重ねるだけで、辞書内のネストされたオブジェクトをどのように呼び出すことができるかを見てきました。

160
00:10:25,750 --> 00:10:27,640
&nbsp;

161
00:10:27,640 --> 00:10:32,450
その後、私たちはキーと値を辞書から取り除く方法を見ました。

162
00:10:32,840 --> 00:10:33,070
大丈夫。

163
00:10:33,070 --> 00:10:34,570
それが辞書の基本です。

164
00:10:34,570 --> 00:10:39,310
辞書の詳細については、次の講義で詳しく説明します。
