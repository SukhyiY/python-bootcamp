1
00:00:05,640 --> 00:00:06,900
みんなを歓迎します。

2
00:00:07,170 --> 00:00:11,460
&nbsp;

3
00:00:11,520 --> 00:00:16,950
&nbsp;

4
00:00:17,100 --> 00:00:20,920
この講義では、前回と同じように続けますが、文字列の索引付けとスライスの索引付けについて議論したり、1文字をスライスしたり、その文字列のサブセクションをつかんでJupiterのノートブックにジャンプしたり、始める。

5
00:00:21,210 --> 00:00:27,180
これをすべてオフにして、私の文字列という変数を作成し、それをHello

6
00:00:27,180 --> 00:00:30,270
worldという文字列と同じように楽しんでいます。

7
00:00:30,270 --> 00:00:36,150
だから私はこれを実行し、ちょうど確かめるためにチェックする、こんにちは世界の間にスペースがあります。

8
00:00:36,430 --> 00:00:36,680
OK。

9
00:00:36,690 --> 00:00:37,610
だから私たちには世界があります。

10
00:00:37,610 --> 00:00:39,540
彼らは行く準備ができている。

11
00:00:39,560 --> 00:00:40,360
想像してみましょう。

12
00:00:40,380 --> 00:00:44,130
私はこの文字列から1文字をつかみたいと思っていました。

13
00:00:44,190 --> 00:00:46,800
その場合、私はインデックスを使用したいと思います。

14
00:00:46,800 --> 00:00:48,660
そこで変数名を呼ぶ。

15
00:00:48,870 --> 00:00:50,670
私たちはそれの角かっこを持っています。

16
00:00:50,760 --> 00:00:56,520
インデックス作成がゼロから始まり、最初の文字hを返すことができるので、私が0である大文字の最初の文字を取得したいとしましょう。

17
00:00:56,520 --> 00:01:01,890
&nbsp;

18
00:01:01,890 --> 00:01:03,690
別のキャラクターをつかもう。

19
00:01:03,690 --> 00:01:05,540
私たちが私たちをつかみたいとしましょう。

20
00:01:05,640 --> 00:01:13,120
だから、これを私の文字列から数えて、0 0 1 2 3 4 5から数えることにしましょう。

21
00:01:13,120 --> 00:01:16,580
スペースが6 7 8になることに注意してください。

22
00:01:16,950 --> 00:01:21,500
だから私がそこに8を渡すなら、それは復帰すべきだと完璧です。

23
00:01:21,510 --> 00:01:24,010
したがって、これもまたインデックス作成と呼ばれています。

24
00:01:24,010 --> 00:01:27,860
さて、この手紙Lを手に入れたいと思ってみましょう。

25
00:01:28,090 --> 00:01:29,790
実際にこれを行うには2つの方法があります。

26
00:01:29,860 --> 00:01:36,970
私は9で私のストリングを言うことができました。それはそれが直後のことです。私がそれを行うことができるもう一つの方法は、前に述べた逆索引付けを使用することです。

27
00:01:37,090 --> 00:01:39,480
&nbsp;

28
00:01:39,700 --> 00:01:46,090
だから、Hから0で始まり、Dが負の1になるように文字列を後ろに進めることができ、それはこのLが負であることを意味します2。

29
00:01:46,180 --> 00:01:47,930
&nbsp;

30
00:01:48,190 --> 00:01:54,220
だから私が私の弦が負の2つであると言うなら、私は実際にそのLを取り戻すでしょう。そして、私が弦の中で後方に向かっていくと、Lの直前に戻ってきます。

31
00:01:54,220 --> 00:01:58,640
&nbsp;

32
00:01:58,660 --> 00:02:00,700
だから私は戻ってきて、そこにいる。

33
00:02:00,700 --> 00:02:07,770
したがって、ポジションとネガティブインデックスの両方の位置を使用して、文字列の要素または文字を取得することができます。

34
00:02:07,960 --> 00:02:12,550
これは本当に便利です。なぜなら可変文字列を持つ人がいるかもしれないし、その名前の大きさがわからないことが多いからです。

35
00:02:12,550 --> 00:02:14,700
&nbsp;

36
00:02:14,860 --> 00:02:19,120
しかし、あなたが名前の最後の手紙をつかみたい理由が何であれ、彼らは常に否定的なものを使うことができます。

37
00:02:19,120 --> 00:02:19,600
&nbsp;

38
00:02:19,630 --> 00:02:21,830
そして、あなたはその文字列の最後の文字だと分かっています。

39
00:02:22,880 --> 00:02:23,230
OK。

40
00:02:23,290 --> 00:02:28,600
スライシングについて議論を続けてみましょう。スライシングは、文字列のサブセクションをつかんでいるので少し複雑です。

41
00:02:28,600 --> 00:02:30,850
&nbsp;

42
00:02:30,850 --> 00:02:33,850
したがって、通常は1文字以上です。

43
00:02:33,850 --> 00:02:41,370
私たちの文字列を見直しましょうここの文字列はこんにちは世界です。私は文字列を見つけることを読むつもりです。

44
00:02:41,440 --> 00:02:47,330
これは、b c d e f g h i j kとして従うのが少し容易です。

45
00:02:47,410 --> 00:02:50,500
それでアルファベットの文字列が見つかるでしょう。

46
00:02:50,830 --> 00:02:53,520
そして今、私はアルファベットのこの文字列を持っています。

47
00:02:53,890 --> 00:02:59,920
それで、特定のインデックスを開始し、最後まで最後まで行った文字列をサブセクションとして取得したいとしましょう。

48
00:02:59,920 --> 00:03:01,470
&nbsp;

49
00:03:01,780 --> 00:03:07,840
私たちができることは、文字列の正方形のブリッケン記法を言うことです。それから開始インデックスを言うでしょう。

50
00:03:07,900 --> 00:03:08,950
&nbsp;

51
00:03:08,950 --> 00:03:12,850
文字Cで始まり、最後まで最後まで行きたいとしましょう。

52
00:03:12,850 --> 00:03:16,950
だから、Cもインデックスなので、0 1 2です。

53
00:03:16,960 --> 00:03:19,900
だから私がやっているのは、私がそれをやるならば、私はそれにパスします。

54
00:03:19,930 --> 00:03:27,480
それは私にCの手紙を返すが、もし私が最後までCから欲しいとすれば、コロンと言うことができ、コロンの隣で始まることが終わりまで続くことを示している。

55
00:03:27,570 --> 00:03:30,890
&nbsp;

56
00:03:31,040 --> 00:03:34,880
そしてそこにはK OKまでCDがあります。

57
00:03:35,090 --> 00:03:40,880
&nbsp;

58
00:03:40,910 --> 00:03:49,200
さあ、私が文字列コロンと言うことができる特定のインデックスまですべてをつかみたいと思う逆の状況を想像してみましょう。私はbとcをつかみたいとしましょう。 だから最初のところから始めて、本質的にDの文字までここで掴んでください。

59
00:03:49,370 --> 00:03:55,440
だから0 1 2 3 pasand 3と言うでしょう。

60
00:03:55,680 --> 00:04:01,090
そして、これを実行し、ABCに戻ります。

61
00:04:01,490 --> 00:04:03,880
今私は私の文字列をチェックするので、時々学生のために混乱しています。

62
00:04:04,130 --> 00:04:09,320
技術的には、0 1 2 3なのでDを3にします。

63
00:04:09,320 --> 00:04:15,120
ここで注意すべき点は、上期インデックスであるABCを返すだけの3つのストップインデックスは、基本的には上向きだが、そのインデックスポジションは含まないということです。

64
00:04:15,140 --> 00:04:20,470
&nbsp;

65
00:04:20,530 --> 00:04:26,920
だから、文字Dに行くが、本質的にA

66
00:04:27,170 --> 00:04:34,040
B Cと書いてあるので、スライス表記の周りを遊んでいるように心に留めておいてください。

67
00:04:34,040 --> 00:04:36,210
&nbsp;

68
00:04:36,230 --> 00:04:43,360
ストップは終わりまでですが、OKを含めずに、開始インデックスと停止インデックスの2つのアイデアを、中間にあるサブセクションまたは文字列を取得しようとすることで組み合わせます。

69
00:04:43,360 --> 00:04:47,160
たとえば、文字列の中央からD

70
00:04:47,230 --> 00:04:54,250
E

71
00:04:54,250 --> 00:05:01,000
Fを取得しようとすると、文字列が角括弧で囲まれていると言うことができます。その後、この例の文字DのExpositionで開始します。

72
00:05:01,000 --> 00:05:01,530
&nbsp;

73
00:05:01,750 --> 00:05:11,060
だからそれは0 1 2 3だからコロンと言うと、私はただDPFが欲しいのでここでGの位置に上がるだろう。

74
00:05:11,060 --> 00:05:12,560
だから我々はGまでは上がるつもりだが、Gを含まない。

75
00:05:12,560 --> 00:05:14,970
だから0 1 2 3 4 5 6です。

76
00:05:15,200 --> 00:05:20,910
そして今私がこれを実行すると、私は元気になる。

77
00:05:20,980 --> 00:05:23,840
だからもう一度、文字列の別のサブセクションをつかむようにしてみましょう。

78
00:05:23,860 --> 00:05:27,720
例えば、bとcをつかむようにしようとしているので、私は私の文字列を開いて閉じているので、私たちはそれを行うことができます。大括弧は解決で始まります。Bコロンは0

79
00:05:27,910 --> 00:05:34,810
1です。 0

80
00:05:35,170 --> 00:05:42,790
1 2 3まで移動するか、これを実行してください。

81
00:05:42,790 --> 00:05:49,310
そして、私たちはB Cを持っています。私はあなたにサブセクションをつかむように勧めます。

82
00:05:49,680 --> 00:05:54,810
&nbsp;

83
00:05:54,810 --> 00:05:59,940
だから真は文字列のサブセクションで、それをつかむことができるかどうかを確かめ、それを試してみてください。

84
00:05:59,940 --> 00:06:00,560
[OK]をクリックしてディスカッションを終了し、ステップサイズについて簡単に説明します。

85
00:06:00,840 --> 00:06:04,450
私は、文字列の始めから最後まですべてをつかみたいと考えてみましょう。

86
00:06:04,740 --> 00:06:09,450
&nbsp;

87
00:06:09,660 --> 00:06:14,580
技術的には文字列そのものですが、コロンコロンと言うこともできるコロン記号を使用することもできます。

88
00:06:14,580 --> 00:06:16,110
そしてそれは基本的には始まりから終わりまでのすべての方法を意味します。

89
00:06:16,110 --> 00:06:20,280
文字列そのものを呼び出すだけの理由から、これはよく見かけることはありません。

90
00:06:20,280 --> 00:06:23,670
しかし、これは技術的に有効な構文です。

91
00:06:23,790 --> 00:06:26,370
&nbsp;

92
00:06:26,370 --> 00:06:31,170
あなたがこのようなものを見る理由は、誰かが3番目のパラメータを指定したいということと、それがステップのサイズです。

93
00:06:31,170 --> 00:06:32,490
&nbsp;

94
00:06:32,730 --> 00:06:38,070
それで今、私たちは、最初から最後まで、そしてステップサイズを1つずつ進んでいると言っています。

95
00:06:38,070 --> 00:06:39,340
デフォルトのステップサイズは1です。

96
00:06:39,360 --> 00:06:41,450
しかし、私は2などの数字を提供することによってそれを変更することができます。

97
00:06:41,460 --> 00:06:44,560
そしてそれは2つのジャンプに行くと言います。

98
00:06:44,760 --> 00:06:46,640
だからC EからGへ。

99
00:06:46,650 --> 00:06:50,690
これを実行すると、私は2のステップサイズでジャンプしているので、私はCEGIKを取得します。これを3ステップサイズに増やすことができます。その後、ジャンプからジャンプしてGジャンプにジャンプします。

100
00:06:50,760 --> 00:06:59,610
。

101
00:06:59,610 --> 00:07:07,910
そして、大きなステップサイズでジャンプしているので、ジャンプする文字はもうありません。

102
00:07:07,920 --> 00:07:11,710
それでは、ステップサイズの仕組みです。

103
00:07:11,730 --> 00:07:13,410
そして、これを開始と停止の両方に組み合わせて停止することもできます。

104
00:07:13,410 --> 00:07:16,480
&nbsp;

105
00:07:16,620 --> 00:07:22,830
インデックスから始まり、インデックス7とステップサイズを含めてCGMを取り戻すようなことを言うことができます。

106
00:07:23,190 --> 00:07:25,220
そこでCはEにジャンプしてからGに飛び乗った。

107
00:07:25,230 --> 00:07:28,580
だから、これがどのように組み合わさって動作するか注意してください

108
00:07:28,590 --> 00:07:30,690
&nbsp;

109
00:07:30,690 --> 00:07:37,630
あなたは、ストップを開始し、次にあなたがよく見るかもしれないステップサイズは、賢いステップを使用しているので、ストリングを逆転させるようにトリックしています。

110
00:07:37,630 --> 00:07:39,930
&nbsp;

111
00:07:40,200 --> 00:07:45,510
あなたがすることができることは、私の弦を言うことです。そして、すべての方法から最初から最後まで言います。

112
00:07:45,510 --> 00:07:46,050
&nbsp;

113
00:07:46,260 --> 00:07:51,900
負の1のステップサイズを取ってください。それは実際にあなたの文字列を逆転させます。なぜなら、すべての方法から始めから終わりまでを言っているからです。

114
00:07:51,900 --> 00:07:55,150
行って、K J.

115
00:07:55,230 --> 00:07:59,000
私。

116
00:07:59,020 --> 00:07:59,370
最後まで。

117
00:07:59,370 --> 00:08:00,590
これは少しPythonのトリックです。

118
00:08:00,660 --> 00:08:02,360
&nbsp;

119
00:08:02,360 --> 00:08:06,960
現在、よくインタビューで人々はあなたに文字列を逆にするように頼んでいます。これは、forループを実行するのではなく素早く素敵な1種類のライナーをすばやく実行するため、Pythonが迷惑をかけるように言います。

120
00:08:06,950 --> 00:08:11,800
しかし、私はあなたにそれを認識してもらいたい。

121
00:08:11,850 --> 00:08:13,620
通常、私たちのコードでは、実際に使用されることはあまりありません。なぜなら、それはより多くのトリックだからです。

122
00:08:13,920 --> 00:08:17,330
しかし、それはまた非常に有用なものです。

123
00:08:17,490 --> 00:08:19,990
OK。

124
00:08:20,400 --> 00:08:20,890
スライスしてインデックスを作成するのはそれだけです。

125
00:08:21,030 --> 00:08:24,120
次に、いくつかの便利な文字列プロパティについて少し説明します。

126
00:08:24,120 --> 00:08:27,860
彼らがいるかどうかがわかります。

127
00:08:27,900 --> 00:08:28,580
&nbsp;
