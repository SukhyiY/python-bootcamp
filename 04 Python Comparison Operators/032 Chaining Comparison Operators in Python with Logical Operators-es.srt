1
00:00:05,900 --> 00:00:06,900
Bienvenido de nuevo a todos.

2
00:00:06,920 --> 00:00:09,470
En la conferencia anterior aprendimos acerca de los operadores de comparación.

3
00:00:09,470 --> 00:00:14,870
Ahora vamos a discutir cómo encadenar diferentes comparaciones y podemos hacer esto con el uso de

4
00:00:14,870 --> 00:00:20,540
lo que se llama operadores lógicos y nos permiten combinar comparaciones y los operadores lógicos clave que

5
00:00:20,540 --> 00:00:22,210
se discutirán aquí son los.

6
00:00:22,220 --> 00:00:25,720
Y la palabra clave the o keyword y the not keyword.

7
00:00:25,790 --> 00:00:29,960
Así que vamos a explorar cómo usar estas palabras clave, así como encadenar comparaciones

8
00:00:29,960 --> 00:00:32,070
sin el uso de estas palabras clave.

9
00:00:32,070 --> 00:00:38,280
De acuerdo, imaginemos que queremos que se ejecute una condición cuando hicimos dos comparaciones.

10
00:00:38,280 --> 00:00:42,220
Por ejemplo, queríamos comprobar si uno era menos de dos.

11
00:00:42,750 --> 00:00:46,880
Y también queríamos verificar al mismo tiempo si dos eran menos de tres.

12
00:00:46,920 --> 00:00:50,690
Entonces, pueden imaginarse que, en lugar de estos números directos, se usarían nombres de variables que tal vez se

13
00:00:50,700 --> 00:00:53,340
cambien a otro lugar en nuestro código, pero para mantener las cosas simples.

14
00:00:53,340 --> 00:00:55,300
Solo estamos usando enteros directos.

15
00:00:55,550 --> 00:00:58,450
Entonces, para cambiar estos dos juntos, podríamos hacer lo siguiente.

16
00:00:58,450 --> 00:01:04,130
Se puede decir que es uno menos de 2 y es 2 menos de tres.

17
00:01:04,200 --> 00:01:05,460
Entonces, cuando ejecutamos esto, regresamos.

18
00:01:05,460 --> 00:01:10,510
Es cierto porque esta comparación de cadena es verdadera y esta comparación es cierta.

19
00:01:10,530 --> 00:01:12,190
Si tuviera que cambiar uno de estos.

20
00:01:12,240 --> 00:01:17,700
Entonces, por ejemplo, si cambio esta tarea a más de 3, obtenemos el falso porque

21
00:01:17,730 --> 00:01:21,650
aunque el primero es verdadero, este segundo ya no es verdadero.

22
00:01:21,660 --> 00:01:26,880
Ahora podría usar este tipo de encadenamiento pero alternativamente puede usar el operador

23
00:01:27,120 --> 00:01:33,520
lógico y el que usaría básicamente para escribir este código aquí es la palabra clave y.

24
00:01:33,750 --> 00:01:39,080
Entonces, en lugar de lo siguiente desde arriba, podría decir que es uno menos que 2.

25
00:01:39,270 --> 00:01:45,930
Y noto que la sintaxis que resalta hay dos más grandes que tres y también hubo

26
00:01:45,930 --> 00:01:46,880
giros falsos.

27
00:01:47,130 --> 00:01:51,110
Y podría cambiar esto para que sea menor en ese momento y luego devuelve verdadero.

28
00:01:51,330 --> 00:01:57,270
Entonces, todas las palabras clave dicen: "Oye, es lo que está a mi izquierda verdadero y lo que está a mi derecha".

29
00:01:57,270 --> 00:02:01,350
Es cierto o recuerde que esto podría ser cualquier tipo de

30
00:02:01,350 --> 00:02:12,920
comparaciones, algunos le mostrarán otra muestra, podríamos hacer algo como Is H igual a h la cadena y dos igual a dos corremos juntos y volveremos a ser ciertos algunas veces

31
00:02:12,980 --> 00:02:15,680
cuando la gente está escribiendo su código.

32
00:02:15,710 --> 00:02:21,080
más de organización como una especie de envoltura de estas comparaciones entre paréntesis y me verás hacer eso de vez en cuando.

33
00:02:21,140 --> 00:02:22,970
A ellos les gusta agregar un poco

34
00:02:23,060 --> 00:02:25,090
Para algunas personas esto es un poco más legible.

35
00:02:25,190 --> 00:02:28,050
Para otros es menos legible porque estás insertando más cosas.

36
00:02:28,100 --> 00:02:30,090
Depende de usted si quiere usar esto o no.

37
00:02:30,110 --> 00:02:34,930
Hay ciertas bibliotecas de las que hablaremos más adelante que requieren que tenga estos paréntesis.

38
00:02:35,090 --> 00:02:38,240
Pero por ahora depende básicamente de ti si crees que el príncipe es más legible.

39
00:02:38,240 --> 00:02:42,930
Adelante y úselas si te gusta que es un poco más elegante sin los paréntesis.

40
00:02:43,070 --> 00:02:48,710
solo ten en cuenta que la palabra clave dice que es lo que está a mi izquierda verdadero y lo que está a mi derecha.

41
00:02:48,710 --> 00:02:50,660
Puedes seguir adelante y hacer eso también, pero

42
00:02:50,660 --> 00:02:51,000
Cierto.

43
00:02:51,020 --> 00:02:52,910
Y luego devuelve un booleano basado en eso.

44
00:02:53,090 --> 00:02:58,100
De acuerdo, es bastante sencillo hasta el momento con la palabra clave que usted sospechó, y que también hay

45
00:02:58,190 --> 00:03:00,460
una palabra clave O que hemos mencionado anteriormente.

46
00:03:00,650 --> 00:03:03,080
Y eso solo necesita una de las condiciones para ser verdad.

47
00:03:03,080 --> 00:03:04,780
Así que de nuevo usaremos números.

48
00:03:04,820 --> 00:03:10,360
Say es 1 igual a 1 o es 2 igual a 2.

49
00:03:10,370 --> 00:03:11,540
Así que corremos eso y volvemos.

50
00:03:11,540 --> 00:03:12,130
Cierto.

51
00:03:12,230 --> 00:03:17,810
Sin embargo, el o solo necesita que una de estas condiciones sea verdadera y ninguna de las dos necesidades, solo necesita una a

52
00:03:17,810 --> 00:03:20,160
la izquierda o una a la derecha para ser verdadera.

53
00:03:20,450 --> 00:03:21,780
Entonces puedo mostrarte lo que quiero decir con eso.

54
00:03:21,860 --> 00:03:22,880
Voy a hacer uno de estos.

55
00:03:22,880 --> 00:03:23,600
Definitivamente no es verdad.

56
00:03:23,600 --> 00:03:25,210
Entonces no es igual a 1.

57
00:03:25,370 --> 00:03:30,470
Pero si ejecuto esto de nuevo, ese es mi recuento de células, todavía dice que es cierto porque solo necesita que uno de

58
00:03:30,470 --> 00:03:31,100
ellos sea cierto.

59
00:03:31,100 --> 00:03:34,990
Entonces esta afirmación es verdadera o es verdadera esta afirmación.

60
00:03:35,440 --> 00:03:39,670
Y si los hacemos ambos falsos, finalmente recuperamos lo falso.

61
00:03:39,800 --> 00:03:44,570
Así que eso es lo básico de encadenar operadores de comparación con la palabra clave y en la palabra clave OR.

62
00:03:44,570 --> 00:03:49,280
Y recomendaría que use estas palabras clave en lugar de hacer algo como esto porque, en mi

63
00:03:49,280 --> 00:03:50,810
opinión, son un poco más legibles.

64
00:03:50,870 --> 00:03:54,130
Por lo tanto, siempre queremos enfatizar la legibilidad en nuestro código.

65
00:03:54,170 --> 00:03:59,030
Es especialmente bueno porque más adelante quizás regrese a su mismo código un

66
00:03:59,030 --> 00:04:01,760
mes después y quiera leer el código fácilmente.

67
00:04:01,760 --> 00:04:02,590
Entonces, acabamos de discutir.

68
00:04:02,670 --> 00:04:05,440
Y luego los operadores lógicos o la palabra clave.

69
00:04:05,560 --> 00:04:11,450
Finalmente quiero analizar la palabra clave no para redondear nuestra discusión mostrándote un ejemplo de la palabra

70
00:04:11,450 --> 00:04:14,210
clave no que es un OT para no.

71
00:04:14,300 --> 00:04:18,880
Básicamente es pedirle que devuelva el booleano opuesto de lo que acaba de hacer.

72
00:04:19,340 --> 00:04:21,690
Entonces construye este buen ejemplo primero.

73
00:04:21,710 --> 00:04:23,030
Entonces uno es igual a uno.

74
00:04:23,090 --> 00:04:24,250
Sabemos que es verdad.

75
00:04:24,500 --> 00:04:30,040
Si quisiéramos obtener por alguna razón la oferta booleana opuesta, no podría hacerlo.

76
00:04:30,440 --> 00:04:35,310
Y luego un príncipe ve uno igual a uno y todos regresan falsos.

77
00:04:35,330 --> 00:04:37,610
Técnicamente no necesitas estos Princie aquí.

78
00:04:37,790 --> 00:04:39,130
Entonces podrías hacer algo como esto.

79
00:04:39,170 --> 00:04:40,760
No uno igual a uno.

80
00:04:40,790 --> 00:04:41,980
Y también vuelves falso.

81
00:04:42,020 --> 00:04:48,440
Depende de usted lo que es más legible, pero no todo lo que está haciendo es pedirle a Bulleen lo que sea

82
00:04:48,440 --> 00:04:49,940
que haya sido devuelto aquí.

83
00:04:49,940 --> 00:04:58,130
Entonces, por ejemplo, solo te lo mostramos de nuevo digamos 400 más que 5000.

84
00:04:58,600 --> 00:04:59,580
Entonces eso es falso

85
00:04:59,650 --> 00:05:03,590
Pero si pongo un nudo delante de él, ahora voy a pedir lo contrario.

86
00:05:03,580 --> 00:05:05,310
Entonces, va a decir verdad.

87
00:05:05,380 --> 00:05:10,690
Por lo tanto, algunas veces no será útil cuando trates de escribir tu lógica, será mucho más obvio cuando comencemos a

88
00:05:10,690 --> 00:05:13,530
discutir el flujo de control en la siguiente sección del curso.

89
00:05:13,600 --> 00:05:15,240
Pero tenga en cuenta esta palabra clave.

90
00:05:15,310 --> 00:05:19,810
Al principio no lo usará con demasiada frecuencia, pero más tarde verá que, a veces, bits y fragmentos

91
00:05:19,810 --> 00:05:22,560
de código se vuelven más legibles con la palabra clave no.

92
00:05:22,720 --> 00:05:27,880
En lugar de usar algo como lo contrario, sabes que habría sido uno que no era igual

93
00:05:27,880 --> 00:05:28,880
a uno allí.

94
00:05:29,020 --> 00:05:29,350
Todo bien.

95
00:05:29,350 --> 00:05:31,020
Eso es lo básico de los operadores lógicos.

96
00:05:31,060 --> 00:05:35,620
Una vez más, lo más importante a tener en cuenta aquí es que la palabra clave necesita que ambas condiciones sean ciertas.

97
00:05:35,850 --> 00:05:39,920
La palabra clave o necesita solo una u otra para ser verdadera.

98
00:05:39,940 --> 00:05:41,190
Nos vemos en la próxima conferencia.
